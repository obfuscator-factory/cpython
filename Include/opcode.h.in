#ifndef Py_OPCODE_H
#define Py_OPCODE_H
#ifdef __cplusplus
extern "C" {{
#endif


/* Instruction opcodes for compiled code */

#define STOP_CODE	{s0}
#define POP_TOP		{s1}
#define ROT_TWO		{s2}
#define ROT_THREE	{s3}
#define DUP_TOP		{s4}
#define ROT_FOUR	{s5}
#define NOP		{s9}

#define UNARY_POSITIVE	{s10}
#define UNARY_NEGATIVE	{s11}
#define UNARY_NOT	{s12}
#define UNARY_CONVERT	{s13}

#define UNARY_INVERT	{s15}

#define BINARY_POWER	{s19}

#define BINARY_MULTIPLY	{s20}
#define BINARY_DIVIDE	{s21}
#define BINARY_MODULO	{s22}
#define BINARY_ADD	{s23}
#define BINARY_SUBTRACT	{s24}
#define BINARY_SUBSCR	{s25}
#define BINARY_FLOOR_DIVIDE {s26}
#define BINARY_TRUE_DIVIDE {s27}
#define INPLACE_FLOOR_DIVIDE {s28}
#define INPLACE_TRUE_DIVIDE {s29}

#define SLICE		{s30}
/* Also uses 31-33 */

#define STORE_SLICE	{s40}
/* Also uses 41-43 */

#define DELETE_SLICE	{s50}
/* Also uses 51-53 */

#define STORE_MAP	{s54}
#define INPLACE_ADD	{s55}
#define INPLACE_SUBTRACT	{s56}
#define INPLACE_MULTIPLY	{s57}
#define INPLACE_DIVIDE	{s58}
#define INPLACE_MODULO	{s59}
#define STORE_SUBSCR	{s60}
#define DELETE_SUBSCR	{s61}

#define BINARY_LSHIFT	{s62}
#define BINARY_RSHIFT	{s63}
#define BINARY_AND	{s64}
#define BINARY_XOR	{s65}
#define BINARY_OR	{s66}
#define INPLACE_POWER	{s67}
#define GET_ITER	{s68}

#define PRINT_EXPR	{s70}
#define PRINT_ITEM	{s71}
#define PRINT_NEWLINE	{s72}
#define PRINT_ITEM_TO   {s73}
#define PRINT_NEWLINE_TO {s74}
#define INPLACE_LSHIFT	{s75}
#define INPLACE_RSHIFT	{s76}
#define INPLACE_AND	{s77}
#define INPLACE_XOR	{s78}
#define INPLACE_OR	{s79}
#define BREAK_LOOP	{s80}
#define WITH_CLEANUP    {s81}
#define LOAD_LOCALS	{s82}
#define RETURN_VALUE	{s83}
#define IMPORT_STAR	{s84}
#define EXEC_STMT	{s85}
#define YIELD_VALUE	{s86}
#define POP_BLOCK	{s87}
#define END_FINALLY	{s88}
#define BUILD_CLASS	{s89}

#define HAVE_ARGUMENT	{s_ward}	/* Opcodes from here have an argument: */

#define STORE_NAME	{s90}	/* Index in name list */
#define DELETE_NAME	{s91}	/* "" */
#define UNPACK_SEQUENCE	{s92}	/* Number of sequence items */
#define FOR_ITER	{s93}
#define LIST_APPEND	{s94}

#define STORE_ATTR	{s95}	/* Index in name list */
#define DELETE_ATTR	{s96}	/* "" */
#define STORE_GLOBAL	{s97}	/* "" */
#define DELETE_GLOBAL	{s98}	/* "" */
#define DUP_TOPX	{s99}	/* number of items to duplicate */
#define LOAD_CONST	{s100}	/* Index in const list */
#define LOAD_NAME	{s101}	/* Index in name list */
#define BUILD_TUPLE	{s102}	/* Number of tuple items */
#define BUILD_LIST	{s103}	/* Number of list items */
#define BUILD_SET	{s104}     /* Number of set items */
#define BUILD_MAP	{s105}	/* Always zero for now */
#define LOAD_ATTR	{s106}	/* Index in name list */
#define COMPARE_OP	{s107}	/* Comparison operator */
#define IMPORT_NAME	{s108}	/* Index in name list */
#define IMPORT_FROM	{s109}	/* Index in name list */
#define JUMP_FORWARD	{s110}	/* Number of bytes to skip */

#define JUMP_IF_FALSE_OR_POP {s111} /* Target byte offset from beginning
                                    of code */
#define JUMP_IF_TRUE_OR_POP {s112}	/* "" */
#define JUMP_ABSOLUTE	{s113}	/* "" */
#define POP_JUMP_IF_FALSE {s114}	/* "" */
#define POP_JUMP_IF_TRUE {s115}	/* "" */

#define LOAD_GLOBAL	{s116}	/* Index in name list */

#define CONTINUE_LOOP	{s119}	/* Start of loop (absolute) */
#define SETUP_LOOP	{s120}	/* Target address (relative) */
#define SETUP_EXCEPT	{s121}	/* "" */
#define SETUP_FINALLY	{s122}	/* "" */

#define LOAD_FAST	{s124}	/* Local variable number */
#define STORE_FAST	{s125}	/* Local variable number */
#define DELETE_FAST	{s126}	/* Local variable number */

#define RAISE_VARARGS	{s130}	/* Number of raise arguments (1, 2 or 3) */
/* CALL_FUNCTION_XXX opcodes defined below depend on this definition */
#define CALL_FUNCTION	{s131}	/* #args + (#kwargs<<8) */
#define MAKE_FUNCTION	{s132}	/* #defaults */
#define BUILD_SLICE 	{s133}	/* Number of items */

#define MAKE_CLOSURE    {s134}     /* #free vars */
#define LOAD_CLOSURE    {s135}     /* Load free variable from closure */
#define LOAD_DEREF      {s136}     /* Load and dereference from closure cell*/
#define STORE_DEREF     {s137}     /* Store into cell */

/* The next 3 opcodes must be contiguous and satisfy
   (CALL_FUNCTION_VAR - CALL_FUNCTION) & 3 == 1  */
#define CALL_FUNCTION_VAR          {s140}	/* #args + (#kwargs<<8) */
#define CALL_FUNCTION_KW           {s141}	/* #args + (#kwargs<<8) */
#define CALL_FUNCTION_VAR_KW       {s142}	/* #args + (#kwargs<<8) */

#define SETUP_WITH {s143}

/* Support for opargs more than 16 bits long */
#define EXTENDED_ARG  {s145}

#define SET_ADD         {s146}
#define MAP_ADD         {s147}



enum cmp_op {{
    PyCmp_LT=Py_LT, PyCmp_LE=Py_LE,
    PyCmp_EQ=Py_EQ, PyCmp_NE=Py_NE,
    PyCmp_GT=Py_GT, PyCmp_GE=Py_GE,
    PyCmp_IN, PyCmp_NOT_IN,
    PyCmp_IS, PyCmp_IS_NOT,
    PyCmp_EXC_MATCH, PyCmp_BAD}};

#define HAS_ARG(op) ((op) >= HAVE_ARGUMENT)

#ifdef __cplusplus
}}
#endif
#endif /* !Py_OPCODE_H */
